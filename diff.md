```
以下内容是对于 diff 算法的详解，虽然有三次 for 循环，但是本质上只是遍历了一次整个 newChild。

# 正餐开始，第一轮遍历
第一轮遍历的核心逻辑是复用和当前节点索引一致的老节点，一旦出现不能复用的情况就跳出遍历。

那么如何复用之前的节点呢？规则如下：

新旧节点都为文本节点，可以直接复用，因为文本节点不需要 key
其他类型节点一律通过判断 key 是否相同来复用或创建节点（可能类型不同但 key 相同）
以下是我简化后的第一轮遍历代码：

for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
  // 找到下一个老的子节点
  nextOldFiber = oldFiber.sibling;
  // 通过 oldFiber 和 newChildren[newIdx] 判断是否可以复用
  // 并给复用出来的节点的 return 属性赋值 returnFiber
  const newFiber = reuse(
    returnFiber,
    oldFiber,
    newChildren[newIdx]
  );
  // 不能复用，跳出
  if (newFiber === null) {
    break;
  }
}
那么回到上文中的例子中，我们老的第一个节点的 key 为 1，新的节点的 key 为 0。key 不相同不能复用，因此直接跳出循环，此时 newIdx 仍 为 0。

# 第二轮遍历
当第一轮遍历结束后，会出现两种情况：

newChild 已经遍历完
老的节点已经遍历完了
当出现 newChild 已经遍历完的情况时只需要把所有剩余的老节点都删除即可。删除的逻辑也就是设置 effectTag 为 Deletion，另外还有几个 fiber 节点属性需要提及下。

当出现需要在渲染阶段进行处理的节点时，会把这些节点放入父节点的 effect 链表中，比如需要被删除的节点就会把加入进链表。这个链表的作用是可以帮助我们在渲染阶段迅速找到需要更新的节点。

当出现老的节点已经遍历完了的情况时，就会开始第二轮遍历。这轮遍历的逻辑很简单，只需要把剩余新的节点全部创建完毕即可。

这轮遍历在我们的例子中是不会执行的，因为我们以上两种情况都不符合。

# 第三轮遍历
第三轮遍历的核心逻辑是找出可以复用的老节点并移动位置，不能复用的话就只能创建一个新的了。

那么问题又再次回到了如何复用节点并移动位置上。首先我们会把所有剩余的老节点都丢到一个 map 中。

我们例子中的代码剩余的老节点为：

<p key={1}>1</p >
<p key={2}>2</p >
那么这个 map 的结构就会是这样的：

// 节点的 key 作为 map 的 key
// 如果节点不存在 key，那么 index 为 key
const map = {
    1: {},
    2: {}
}
在遍历的过程中会寻找新的节点的 key 是否存在于这个 map 中，存在即可复用，不存在就只能创建一个新的了。其实这部分的复用及创建的逻辑和第一轮中的是一模一样的，所以也就不再赘述了。

那么如果复用成功，就应该把复用的 key 从 map 中删掉，并且给复用的节点移动位置。这里的移动依旧不涉及 DOM 操作，而是给 effectTag 赋值为 Placement。

此轮遍历结束后，就把还存在于 map 中的所有老节点删除。

# 小结
以上就是 diff 子节点的全部逻辑，对比 React 15 的 diff 策略而言个人认为代码好懂了许多。
```